{
  "name": "level-mutex",
  "version": "0.7.0",
  "description": "Mutex read/write lock for levelup.",
  "main": "index.js",
  "dependencies": {
    "level-peek": "~1.0.6"
  },
  "devDependencies": {
    "cleanup": "~0.3.0",
    "okdone": "~0.3.0",
    "async": "~0.2.9",
    "rimraf": "~2.2.0",
    "levelup": "~0.10.0",
    "leveldown": "~0.6.1"
  },
  "scripts": {
    "test": "node test.js"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/mikeal/level-mutex"
  },
  "keywords": [
    "level",
    "leveldb",
    "lock",
    "mutex",
    "transaction"
  ],
  "author": {
    "name": "Mikeal Rogers"
  },
  "license": "BSD",
  "readme": "### level-mutex\n\n`npm install level-mutex`\n\n#### What is this?\n\n`level-mutex` is an abstract \"lock\" around a `levelup` store. What it does is cycle between reads and writes, allowing all writes to return in order while queuing all reads, then running all reads and returning in order, then writing all the pending writes again. `level-mutex` uses node.js' single threaded nature to your advantage so that you can maintain a higher order locking structure to insure various types of read-on-write consistency semantics.\n\nThis is currently used in [couchup](http://github.com/mikeal/couchup) to ensure users cannot update a document without providing the latest revision.\n\nWhile you do scope `level-mutex` to a single levelup store there is nothing stopping you from having many mutexes around the same store provided you're using each to manage a separate higher order consistency guarantee. For instance, `couchup` uses a mutex *per database* and an indefinite number of databases might exist in a single levelup store.\n\n```javascript\nvar levelup = require('levelup')\n  , mutex = require('level-mutex')\n  ;\n\nvar store = levelup('./testdb')\n  , mymutex = mutex(store)\n  , pending = []\n  ;\n\nfunction write (key, revision, value, cb) {\n  mymutex.get(key, function (e, val) {\n    // verify that the revision being written is the current one in the database\n    if (e || value.revision !=== revision) return cb(new Error('rev is out of date'))\n    // if this key is being written then nobody has read it yet which means\n    // someone writing it can't be writing to the new revision\n    if (pending.indexOf(key) !== -1) return cb(new Error('rev is out of date'))\n    pending.push(key)\n    // bump the rev\n    value.revision = value.revision + 1\n    mymutex.put(key, value, function (e) {\n      if (e) return cb(e)\n      cb(null, {rev:value.revision})\n    })\n  })\n}\n\n// flush all pending keys when writes have been flushed.\nmymutex.on('flushed', function () {\n  pending = []\n})\n```\n\n#### methods\n\n* get\n* put\n* del\n* peekLast\n* peekFirst\n* afterWrite\n\n\n#### events\n\n* reads\n* writes\n* flushed",
  "readmeFilename": "readme.md",
  "bugs": {
    "url": "https://github.com/mikeal/level-mutex/issues"
  },
  "_id": "level-mutex@0.7.0",
  "dist": {
    "shasum": "0f4b5bd1e5b29df519641590b56aab7632f1a2ff",
    "tarball": "http://registry.npmjs.org/level-mutex/-/level-mutex-0.7.0.tgz"
  },
  "_from": "level-mutex@>=0.7.0 <0.8.0",
  "_npmVersion": "1.3.2",
  "_npmUser": {
    "name": "mikeal",
    "email": "mikeal.rogers@gmail.com"
  },
  "maintainers": [
    {
      "name": "mikeal",
      "email": "mikeal.rogers@gmail.com"
    }
  ],
  "directories": {},
  "_shasum": "0f4b5bd1e5b29df519641590b56aab7632f1a2ff",
  "_resolved": "https://registry.npmjs.org/level-mutex/-/level-mutex-0.7.0.tgz",
  "homepage": "https://github.com/mikeal/level-mutex"
}
